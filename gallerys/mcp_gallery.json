{
    "id": "gallery_1737176083648",
    "name": "MCP Component Gallery",
    "metadata": {
      "author": "AutoGen Team",
      "created_at": "2025-01-18T00:00:00Z",
      "updated_at": "2025-01-20T05:49:38.784Z",
      "version": "1.0.0",
      "description": "An MCP gallery containing basic components for human-in-loop conversations",
      "tags": [
        "human-in-loop",
        "assistant"
      ],
      "license": "MIT",
      "category": "conversation"
    },
    "items": {
      "teams": [
        {
          "component_type": "team",
          "description": "A team with an assistant agent and a user proxy agent to enable human-in-loop task completion in a round-robin fashion",
          "name": "huma_in_loop_team_updated",
          "participants": [
            {
              "component_type": "agent",
              "description": "An assistant agent that can help users complete tasks",
              "name": "assistant_agent",
              "agent_type": "AssistantAgent",
              "system_message": "You are a helpful assistant. Solve tasks carefully. Use the tools provided to assist in completing the tasks. When the task is done respond with TERMINATE.",
              "model_client": {
                "component_type": "model",
                "description": "A GPT-4o model",
                "model": "gpt-4o",
                "model_type": "OpenAIChatCompletionClient"
              },
              "tools": [
                {
                    "component_type": "tool",
                    "name": "mcp",
                    "description": "Access MCP (Model Context Protocol) servers with focus on two key capabilities:\n\n1. List available servers\n   Example: mcp(tool='list_available_servers')\n\n2. Get details about tools on a server\n   Example: mcp(server='server_name', tool='tool_details')\n\nMain servers include:\n- filesystem: For file operations\n- brave-search: For web search capabilities\n\nIMPORTANT:\n1. Always check tool details before use to understand required parameters and proper usage. Do not make assumptions about how tools work - use tool_details to verify the correct parameters and format.\n\n2. The user cannot see the raw tool results - you must always provide a clear summary of what the tool did and what was found. For example:\n   - When reading a file: Explain what was in the file\n   - When searching: Summarize the search results\n   - When listing directories: Describe what was found\n\nNever just execute a tool without explaining its results to the user. Always interpret and explain the output in a way that's meaningful to the user.",
                    "content": "async def mcp(server: str = None, tool: str = None, query: str = None, path: str = None, count: int = None) -> str:\n    \"\"\"MCP (Model Context Protocol) provides access to various tools and servers.\n    Before using any tools, you should:\n\n    1. List available servers:\n       mcp(tool='list_available_servers')\n\n    2. Get details about tools on a server:\n       mcp(server='server_name', tool='tool_details')\n\n    Main servers include:\n    - filesystem: For file operations \n    - brave-search: For web search capabilities\n\n    IMPORTANT: Always check tool details before use to understand required parameters\n    and proper usage. Do not make assumptions about how tools work - use tool_details\n    to verify the correct parameters and format.\n\n    The user cannot see the raw tool results - you must always provide a clear summary\n    of what the tool did and what was found. For example:\n    - When reading a file: Explain what was in the file\n    - When searching: Summarize the search results\n    - When listing directories: Describe what was found\n\n    Never just execute a tool without explaining its results to the user. Always interpret\n    and explain the output in a way that's meaningful to the user.\n    \"\"\"\n    try:\n        import json\n        import asyncio\n        import os\n        import platform\n        from pathlib import Path\n        from mcp import ClientSession, StdioServerParameters\n        from mcp.client.stdio import stdio_client\n\n        # Get system-specific config path\n        system = platform.system()\n        home = Path.home()\n        \n        if system == \"Darwin\":  # macOS\n            config_path = home / \"Library/Application Support/Claude/claude_desktop_config.json\"\n            default_npx = Path(\"/opt/homebrew/bin/npx\")\n        elif system == \"Windows\":\n            config_path = Path(os.getenv(\"APPDATA\")) / \"Claude/claude_desktop_config.json\"\n            default_npx = Path(os.getenv(\"APPDATA\")) / \"npm/npx.cmd\"\n        else:  # Linux and others\n            config_path = home / \".config/Claude/claude_desktop_config.json\"\n            default_npx = Path(\"/usr/local/bin/npx\")\n\n        # Find npx in PATH if default doesn't exist\n        npx_path = str(default_npx if default_npx.exists() else \"npx\")\n\n        # Load config\n        with open(config_path) as f:\n            servers = json.load(f).get('mcpServers', {})\n\n        # Handle special tool cases first\n        if tool == 'list_available_servers':\n            return json.dumps(list(servers.keys()), indent=2)\n\n        # Require server parameter for all other operations\n        if not server:\n            return \"Error: Server parameter required for tool operations\"\n        if server not in servers:\n            return f\"Error: Server {server} not found\"\n\n        # Build server config\n        config = servers[server]\n        command = npx_path if config['command'] == 'npx' else config['command']\n        env = os.environ.copy()\n        env.update(config.get('env', {}))\n\n        # Build arguments based on tool\n        args = {}\n        if path is not None:\n            args['path'] = path\n        if query is not None:\n            args['query'] = query\n        if count is not None:\n            args['count'] = count\n\n        # Execute tool\n        async with stdio_client(StdioServerParameters(command=command, args=config.get('args', []), env=env)) as (read, write):\n            async with ClientSession(read, write) as session:\n                await session.initialize()\n                if tool == 'tool_details':\n                    result = await session.list_tools()\n                    return json.dumps([{\n                        'name': tool.name,\n                        'description': tool.description,\n                        'input_schema': tool.inputSchema\n                    } for tool in result.tools], indent=2)\n                result = await session.call_tool(tool, arguments=args)\n                return str(result)\n\n    except Exception as e:\n        return f\"Error: {str(e)}\"",
                    "tool_type": "PythonFunction"
                }
              ]
            },
            {
              "component_type": "agent",
              "description": "A user agent that is driven by a human user",
              "name": "user_agent",
              "agent_type": "UserProxyAgent",
              "tools": []
            }
          ],
          "team_type": "RoundRobinGroupChat",
          "termination_condition": {
            "component_type": "termination",
            "termination_type": "TextMentionTermination",
            "text": "TERMINATE"
          }
        }
      ],
      "components": {
        "agents": [
          {
            "component_type": "agent",
            "description": "An assistant agent that can help users complete tasks",
            "name": "assistant_agent",
            "agent_type": "AssistantAgent",
            "system_message": "You are a helpful assistant. Solve tasks carefully. Use the tools provided to assist in completing the tasks. When the task is done respond with TERMINATE.",
            "model_client": {
              "component_type": "model",
              "description": "A GPT-4o model",
              "model": "gpt-4o",
              "model_type": "OpenAIChatCompletionClient"
            },
            "tools": [
                {
                    "component_type": "tool",
                    "name": "mcp",
                    "description": "Access MCP (Model Context Protocol) servers with focus on two key capabilities:\n\n1. List available servers\n   Example: mcp(tool='list_available_servers')\n\n2. Get details about tools on a server\n   Example: mcp(server='server_name', tool='tool_details')\n\nMain servers include:\n- filesystem: For file operations\n- brave-search: For web search capabilities\n\nIMPORTANT:\n1. Always check tool details before use to understand required parameters and proper usage. Do not make assumptions about how tools work - use tool_details to verify the correct parameters and format.\n\n2. The user cannot see the raw tool results - you must always provide a clear summary of what the tool did and what was found. For example:\n   - When reading a file: Explain what was in the file\n   - When searching: Summarize the search results\n   - When listing directories: Describe what was found\n\nNever just execute a tool without explaining its results to the user. Always interpret and explain the output in a way that's meaningful to the user.",
                    "content": "async def mcp(server: str = None, tool: str = None, query: str = None, path: str = None, count: int = None) -> str:\n    \"\"\"MCP (Model Context Protocol) provides access to various tools and servers.\n    Before using any tools, you should:\n\n    1. List available servers:\n       mcp(tool='list_available_servers')\n\n    2. Get details about tools on a server:\n       mcp(server='server_name', tool='tool_details')\n\n    Main servers include:\n    - filesystem: For file operations \n    - brave-search: For web search capabilities\n\n    IMPORTANT: Always check tool details before use to understand required parameters\n    and proper usage. Do not make assumptions about how tools work - use tool_details\n    to verify the correct parameters and format.\n\n    The user cannot see the raw tool results - you must always provide a clear summary\n    of what the tool did and what was found. For example:\n    - When reading a file: Explain what was in the file\n    - When searching: Summarize the search results\n    - When listing directories: Describe what was found\n\n    Never just execute a tool without explaining its results to the user. Always interpret\n    and explain the output in a way that's meaningful to the user.\n    \"\"\"\n    try:\n        import json\n        import asyncio\n        import os\n        import platform\n        from pathlib import Path\n        from mcp import ClientSession, StdioServerParameters\n        from mcp.client.stdio import stdio_client\n\n        # Get system-specific config path\n        system = platform.system()\n        home = Path.home()\n        \n        if system == \"Darwin\":  # macOS\n            config_path = home / \"Library/Application Support/Claude/claude_desktop_config.json\"\n            default_npx = Path(\"/opt/homebrew/bin/npx\")\n        elif system == \"Windows\":\n            config_path = Path(os.getenv(\"APPDATA\")) / \"Claude/claude_desktop_config.json\"\n            default_npx = Path(os.getenv(\"APPDATA\")) / \"npm/npx.cmd\"\n        else:  # Linux and others\n            config_path = home / \".config/Claude/claude_desktop_config.json\"\n            default_npx = Path(\"/usr/local/bin/npx\")\n\n        # Find npx in PATH if default doesn't exist\n        npx_path = str(default_npx if default_npx.exists() else \"npx\")\n\n        # Load config\n        with open(config_path) as f:\n            servers = json.load(f).get('mcpServers', {})\n\n        # Handle special tool cases first\n        if tool == 'list_available_servers':\n            return json.dumps(list(servers.keys()), indent=2)\n\n        # Require server parameter for all other operations\n        if not server:\n            return \"Error: Server parameter required for tool operations\"\n        if server not in servers:\n            return f\"Error: Server {server} not found\"\n\n        # Build server config\n        config = servers[server]\n        command = npx_path if config['command'] == 'npx' else config['command']\n        env = os.environ.copy()\n        env.update(config.get('env', {}))\n\n        # Build arguments based on tool\n        args = {}\n        if path is not None:\n            args['path'] = path\n        if query is not None:\n            args['query'] = query\n        if count is not None:\n            args['count'] = count\n\n        # Execute tool\n        async with stdio_client(StdioServerParameters(command=command, args=config.get('args', []), env=env)) as (read, write):\n            async with ClientSession(read, write) as session:\n                await session.initialize()\n                if tool == 'tool_details':\n                    result = await session.list_tools()\n                    return json.dumps([{\n                        'name': tool.name,\n                        'description': tool.description,\n                        'input_schema': tool.inputSchema\n                    } for tool in result.tools], indent=2)\n                result = await session.call_tool(tool, arguments=args)\n                return str(result)\n\n    except Exception as e:\n        return f\"Error: {str(e)}\"",
                    "tool_type": "PythonFunction"
                }
            ]
          },
          {
            "component_type": "agent",
            "description": "A user agent that is driven by a human user",
            "name": "user_agent",
            "agent_type": "UserProxyAgent",
            "tools": []
          }
        ],
        "models": [
          {
            "component_type": "model",
            "description": "A GPT-4o model",
            "model": "gpt-4o",
            "model_type": "OpenAIChatCompletionClient"
          }
        ],
        "tools": [
          {
            "component_type": "tool",
            "name": "mcp",
            "description": "MCP (Model Context Protocol) is like a universal adapter that gives you access to an expanding collection of powerful tools - think 'USB for AI tools'. From web search to file operations, image generation to browser automation, MCP connects you to a growing ecosystem of capabilities.",
            "tool_type": "PythonFunction"
          }
        ],
        "terminations": [
          {
            "component_type": "termination",
            "description": "Terminate the conversation when the user mentions 'TERMINATE'",
            "termination_type": "TextMentionTermination",
            "text": "TERMINATE"
          }
        ]
      }
    }
}

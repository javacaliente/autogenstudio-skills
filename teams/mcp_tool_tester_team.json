{
  "version": "1.0.0",
  "component_type": "team",
  "name": "new_team_1737352488588",
  "participants": [
    {
      "component_type": "agent",
      "name": "assistant_agent",
      "agent_type": "AssistantAgent",
      "system_message": "You are a helpful assistant. Solve tasks carefully. You have a tool called MCP, this is USB for llm context, it's a set of tools. You will be asked to do MCP tools tests and validate the different options you can use with them. When the task is done respond with TERMINATE.",
      "model_client": {
        "component_type": "model",
        "model": "gpt-4o-2024-08-06",
        "model_type": "OpenAIChatCompletionClient"
      },
      "tools": [
          {
            "component_type": "tool",
            "name": "mcp",
            "description": "Access MCP (Model Context Protocol) servers for search and file operations. Before using any tool, you should:\n\n1. Get available tools:\n   mcp(server='server_name', tool='tool_details')\n\nAvailable Servers:\n\n1. brave-search:\n   - brave_web_search: Search the web\n   - brave_local_search: Find local places and businesses\n\n2. filesystem:\n   - read_file: Read file contents\n   - write_file: Create or update files\n   - edit_file: Make changes to files\n   - create_directory: Create new directories\n   - list_directory: Show directory contents\n   - directory_tree: Get recursive file listing\n   - move_file: Move or rename files\n   - search_files: Find files by pattern\n   - get_file_info: Get file metadata\n\nIMPORTANT: Always explain tool results to the user, for example:\n- When reading a file: What's in the file\n- When searching: Summary of results\n- When listing directories: What was found",
            "content": "async def mcp(\n    server: str = None,\n    tool: str = None,\n    query: str = None,\n    path: str = None,\n    count: int = None,\n    content: str = None,\n    edits: list = None,\n    paths: list = None,\n    source: str = None,\n    destination: str = None,\n    pattern: str = None,\n    excludePatterns: list = None,\n    dryRun: bool = None\n) -> str:\n    \"\"\"MCP (Model Context Protocol) provides access to various tools and servers.\n    Always start by checking available tools:\n\n    1. Get tool details:\n       mcp(server='server_name', tool='tool_details')\n\n    Server Capabilities:\n\n    brave-search:\n    - brave_web_search(query, count=10): Web search\n    - brave_local_search(query, count=5): Find local businesses\n\n    filesystem:\n    - read_file(path)\n    - write_file(path, content)\n    - edit_file(path, edits)\n    - create_directory(path)\n    - list_directory(path)\n    - directory_tree(path)\n    - move_file(source, destination)\n    - search_files(path, pattern)\n    - get_file_info(path)\n\n    Use tool_details for complete documentation of each tool.\n    Always explain results clearly to users.\n    \"\"\"\n    try:\n        import json\n        import asyncio\n        import os\n        import platform\n        from pathlib import Path\n        from mcp import ClientSession, StdioServerParameters\n        from mcp.client.stdio import stdio_client\n\n        # Get config path from environment or use a default one\n        home = Path.home()\n        config_path = Path(os.getenv('MCP_CONFIG_PATH', str(home / 'claude_home/autogenstudio-skills/mcp_config.json')))\n\n        if not config_path.exists():\n            return f\"Error: No configuration file found at {config_path}\"\n\n        # Get system-specific npx path\n        system = platform.system()\n        if system == \"Darwin\":  # macOS\n            default_npx = Path(\"/opt/homebrew/bin/npx\")\n        elif system == \"Windows\":\n            default_npx = Path(os.getenv(\"APPDATA\")) / \"npm/npx.cmd\"\n        else:  # Linux and others\n            default_npx = Path(\"/usr/local/bin/npx\")\n\n        # Find npx in PATH if default doesn't exist\n        npx_path = str(default_npx if default_npx.exists() else \"npx\")\n\n        # Load config\n        with open(config_path) as f:\n            config_data = json.load(f)\n            servers = config_data.get('mcpServers', {})\n\n        # Handle special tool cases first\n        if tool == 'list_available_servers':\n            # Only return enabled servers\n            enabled_servers = [name for name, cfg in servers.items() if cfg.get('enabled', True)]\n            return json.dumps(enabled_servers, indent=2)\n\n        # Require server parameter for all other operations\n        if not server:\n            return \"Error: Server parameter required for tool operations\"\n        if server not in servers:\n            return f\"Error: Server {server} not found\"\n        if not servers[server].get('enabled', True):\n            return f\"Error: Server {server} is disabled in configuration\"\n\n        # Build server config\n        config = servers[server]\n        command = npx_path if config['command'] == 'npx' else config['command']\n        env = os.environ.copy()\n        env.update(config.get('env', {}))\n\n        # Build arguments based on tool\n        args = {}\n        if path is not None:\n            args['path'] = path\n        if query is not None:\n            args['query'] = query\n        if count is not None:\n            args['count'] = count\n        if content is not None:\n            args['content'] = content\n        if edits is not None:\n            args['edits'] = edits\n        if paths is not None:\n            args['paths'] = paths\n        if source is not None:\n            args['source'] = source\n        if destination is not None:\n            args['destination'] = destination\n        if pattern is not None:\n            args['pattern'] = pattern\n        if excludePatterns is not None:\n            args['excludePatterns'] = excludePatterns\n        if dryRun is not None:\n            args['dryRun'] = dryRun\n\n        # Execute tool\n        async with stdio_client(StdioServerParameters(command=command, args=config.get('args', []), env=env)) as (read, write):\n            async with ClientSession(read, write) as session:\n                await session.initialize()\n                if tool == 'tool_details':\n                    result = await session.list_tools()\n                    return json.dumps([{\n                        'name': tool.name,\n                        'description': tool.description,\n                        'input_schema': tool.inputSchema\n                    } for tool in result.tools], indent=2)\n                result = await session.call_tool(tool, arguments=args)\n                return str(result)\n\n    except Exception as e:\n        return f\"Error: {str(e)}\"",
            "tool_type": "PythonFunction"
          }
      ]
    }
  ],
  "team_type": "RoundRobinGroupChat",
  "termination_condition": {
    "component_type": "termination",
    "termination_type": "TextMentionTermination",
    "text": "TERMINATE"
  }
}